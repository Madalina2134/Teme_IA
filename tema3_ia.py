# -*- coding: utf-8 -*-
"""Tema3_IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12BU7tQOeVgE1MRjw8D8YfFnJxXuh2zGM
"""

# IMPORTURI

import pandas as pd
import time
import matplotlib.pyplot as plt

from mlxtend.frequent_patterns import fpgrowth, apriori, association_rules



# 1. INCARCARE DATE
cons = pd.read_csv("consumption_user.csv")


# 2. SELECTARE COLOANE RELEVANTE
df = cons[['SUBJECT', 'SURVEY_DAY', 'FOODEX2_INGR_CODE', 'FOOD_AMOUNT_CONS']]

# eliminam inregistrarile fara consum efectiv
df = df[df['FOOD_AMOUNT_CONS'] > 0].copy()

# 3. VARIABILA BINARA (CONSUMAT / NU)
df['Consumed'] = True   # boolean pentru performanta mai buna


# 4. CONSTRUIREA TRANZACTIILOR (INDIVID + ZI)
basket = (
    df.groupby(['SUBJECT', 'SURVEY_DAY', 'FOODEX2_INGR_CODE'])['Consumed']
      .max()
      .unstack(fill_value=False)
)

print("Dimensiunea matricei tranzacționale:", basket.shape)



# 5. COMPARAȚIE FP-GROWTH vs APRIORI (PERFORMANTA)
supports = [0.02, 0.04, 0.06, 0.08]

fp_times = []
ap_times = []

fp_counts = []
ap_counts = []

for s in supports:
    # FP-Growth
    start = time.time()
    fp_itemsets = fpgrowth(basket, min_support=s)
    fp_times.append(time.time() - start)
    fp_counts.append(len(fp_itemsets))

    # Apriori
    start = time.time()
    ap_itemsets = apriori(basket, min_support=s)
    ap_times.append(time.time() - start)
    ap_counts.append(len(ap_itemsets))



# GRAFICUL 1: TIMP DE EXECUTIE

plt.figure()
plt.plot(supports, fp_times, marker='o', label='FP-Growth')
plt.plot(supports, ap_times, marker='o', label='Apriori')
plt.xlabel("Pragul minim de support")
plt.ylabel("Timp de execuție (secunde)")
plt.title("Compararea timpului de execuție: FP-Growth vs Apriori")
plt.legend()
plt.show()



# GRAFICUL 2: NUMAR ITEMSET-URI

plt.figure()
plt.plot(supports, fp_counts, marker='o', label='FP-Growth')
plt.plot(supports, ap_counts, marker='o', label='Apriori')
plt.xlabel("Pragul minim de support")
plt.ylabel("Număr de itemset-uri frecvente")
plt.title("Numărul de itemset-uri generate: FP-Growth vs Apriori")
plt.legend()
plt.show()


# 6. FP-GROWTH + REGULI DE ASOCIERE

frequent_itemsets = fpgrowth(
    basket,
    min_support=0.05,
    use_colnames=True,
    max_len=3
)

rules = association_rules(
    frequent_itemsets,
    metric="confidence",
    min_threshold=0.6
)

# filtrare reguli relevante
rules = rules[rules['lift'] > 1.2]


# GRAFICUL 3: SUPPORT vs LIFT

plt.figure()
plt.scatter(rules['support'], rules['lift'])
plt.xlabel("Support")
plt.ylabel("Lift")
plt.title("Relația dintre support și lift pentru regulile FP-Growth")
plt.show()


# AFISARE REGULI

print(
    rules[['antecedents', 'consequents', 'support', 'confidence', 'lift']]
    .sort_values('lift', ascending=False)
    .head(10)
)


#  MAPARE COD FOODEX2 -> DENUMIRE ALIMENT

# dictionar cod -> descriere ingredient
food_dict = (
    cons[['FOODEX2_INGR_CODE', 'FOODEX2_INGR_DESCR']]
    .dropna()
    .drop_duplicates()
    .set_index('FOODEX2_INGR_CODE')['FOODEX2_INGR_DESCR']
    .to_dict()
)

# functie pentru conversia codurilor din reguli in denumiri
def decode_itemset(itemset):
    return [food_dict.get(code, code) for code in itemset]

# aplicam conversia doar pentru afisare
rules_readable = rules.copy()
rules_readable['antecedents_named'] = rules_readable['antecedents'].apply(decode_itemset)
rules_readable['consequents_named'] = rules_readable['consequents'].apply(decode_itemset)

# afisam regulile intr-o forma lizibila
print(
    rules_readable[
        ['antecedents_named', 'consequents_named', 'support', 'confidence', 'lift']
    ]
    .sort_values('lift', ascending=False)
    .head(10)
)

# AFISARE ELEGANTA A REGULILOR
def format_rule(row):
    antecedent = ", ".join(row['antecedents_named'])
    consequent = ", ".join(row['consequents_named'])
    return (
        f"{antecedent}  ⇒  {consequent}\n"
        f"   support = {row['support']:.3f}, "
        f"confidence = {row['confidence']:.2f}, "
        f"lift = {row['lift']:.2f}\n"
    )

top_rules = (
    rules_readable
    .sort_values('lift', ascending=False)
    .head(10)
)

for _, row in top_rules.iterrows():
    print(format_rule(row))





#REGULI GENERATE
# Wheat bread and rolls, white (refined flour), Sucrose (common sugar)  ⇒  Cocoa beverage-preparation, powder
#    support = 0.056, confidence = 0.64, lift = 11.36

# Cocoa beverage-preparation, powder  ⇒  Wheat bread and rolls, white (refined flour), Sucrose (common sugar)
#    support = 0.056, confidence = 1.00, lift = 11.36

# Cocoa beverage-preparation, powder, Sucrose (common sugar)  ⇒  Wheat bread and rolls, white (refined flour)
#    support = 0.056, confidence = 1.00, lift = 10.42

# Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole, Chili peppers, PROCESS = Raw, no heat treatment, PROCESS = Boiling, QUALITATIVE-INFO = Red  ⇒  Wheat bread and rolls, white (refined flour)
#    support = 0.056, confidence = 1.00, lift = 10.42

# Cocoa beverage-preparation, powder  ⇒  Wheat bread and rolls, white (refined flour)
#    support = 0.056, confidence = 1.00, lift = 10.42

# Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole  ⇒  Wheat bread and rolls, white (refined flour), Sucrose (common sugar)
#    support = 0.064, confidence = 0.89, lift = 10.10

# Wheat bread and rolls, white (refined flour), Sucrose (common sugar)  ⇒  Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole
#    support = 0.064, confidence = 0.73, lift = 10.10

# Wheat bread and rolls, white (refined flour)  ⇒  Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole
#    support = 0.064, confidence = 0.67, lift = 9.26

# Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole, Sucrose (common sugar)  ⇒  Wheat bread and rolls, white (refined flour)
#    support = 0.064, confidence = 0.89, lift = 9.26

# Wheat bread and rolls, white (refined flour)  ⇒  Milk powder, full fat, SOURCE-COMMODITIES = Cow milk, whole, Sucrose (common sugar)
#    support = 0.064, confidence = 0.67, lift = 9.26





